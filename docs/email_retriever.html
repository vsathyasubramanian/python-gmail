<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>src.email_retriever API documentation</title>
<meta name="description" content="this file contains the EmailRetriever class which hosts the methods containing the business logic to help us with
retrieving emails from server using â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.email_retriever</code></h1>
</header>
<section id="section-intro">
<p>this file contains the EmailRetriever class which hosts the methods containing the business logic to help us with
retrieving emails from server using appropriate connectors.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
this file contains the EmailRetriever class which hosts the methods containing the business logic to help us with
retrieving emails from server using appropriate connectors.

&#34;&#34;&#34;
__author__ = &#34;sathya.v&#34;

import base64
import email

import mysql.connector
from dateutil.parser import parse
from google_connector import GoogleConnector

from email_dao import EmailDAO
from email_entity import EmailEntity
from config import DATABASE, DB_PASSWORD, DB_USERNAME


class EmailRetriever:
    &#34;&#34;&#34;
    Email Retriever class hosting core methods to retrieve email content
        uses the appropriate strategy method
        using connector object authenticates and fetches all the emails from server
        parses the response message and populates the email entity
        stores the email entity in the local database
    &#34;&#34;&#34;

    def __init__(self):
        self.email_obj_list = []
        self.db_obj = mysql.connector.connect(
            host=&#34;localhost&#34;,
            user=DB_USERNAME,
            password=DB_PASSWORD,
            database=DATABASE
        )
        self.retrieve_email_strategy_mapper = {
            &#39;google&#39;: self.retrieve_email_google_strategy
        }

    def retrieve_email_google_strategy(self, credentials_path):
        &#34;&#34;&#34;
        Brief:
            Google Email pull strategy method which pulls emails from google servers and populates the local
            email entity

        Pseudo-code:
            calls authentication module first to authenticate and retrieve the OAuth token
            calls batch get email method to retrieve email content from mail server
            calls parse message method to parse and load the email data onto the entity
        Args:
            credentials_path: Path of the credential and token file

        Returns:

        &#34;&#34;&#34;
        try:
            google_services_obj = GoogleConnector(credentials_path=credentials_path)
            print(&#34;Authenticating...&#34;)
            google_services_obj.authenticate()
            print(&#34;Authentication Complete...&#34;)
            google_services_obj.batch_get_emails(parser=self.parse_and_load_messages, criteria=None)
        except Exception as ex:
            print(&#34;exception in connecting to google services and fetching email content :: %s&#34; % ex)
            raise

    def parse_and_load_messages(self, request_id, response, exception):
        &#34;&#34;&#34;
        Brief:
            Method to parse the response and populate the email entity with the appropriate values
        Args:
            request_id: int request id
            response: response object
            exception: HttpError/None
        Returns:
            mail_entity: object
        &#34;&#34;&#34;
        try:
            if exception:
                print(&#34;HTTP error in processing the request&#34;)
                raise
            print(&#34;Parsing message request_id ::&#34; + str(request_id), flush=True)
            email_obj = EmailEntity()
            message_str = base64.urlsafe_b64decode(response[&#39;raw&#39;].encode(&#39;ASCII&#39;))
            email_obj.message_id = response[&#39;id&#39;]
            email_obj.labels = response[&#39;labelIds&#39;]
            mime_message = email.message_from_string(message_str.decode(&#39;ascii&#39;))
            email_obj.from_address = mime_message[&#39;From&#39;]
            email_obj.to_address = mime_message[&#39;To&#39;]
            email_obj.subject = mime_message[&#39;Subject&#39;]
            email_obj.date = parse(mime_message[&#39;Date&#39;], ignoretz=True)
            for parts in mime_message.walk():
                if parts.get_content_type() == &#39;text/plain&#39;:
                    if parts.get(&#39;Content-Transfer-Encoding&#39;):
                        message_content = base64.urlsafe_b64decode(parts.get_payload().encode(&#39;UTF-8&#39;))
                        email_obj.content = message_content.decode(&#39;UTF-8&#39;)
                    else:
                        email_obj.content = parts.get_payload()
            self.email_obj_list.append(email_obj)
        except Exception as ex:
            print(&#34;Exception in parsing email content and populating the entity :: %s&#34; % ex)
            raise

    def store_email_snapshots(self):
        &#34;&#34;&#34;
        Brief:
            Method to store the fetched emails in the database.
        Returns:
            Status: True/False
        &#34;&#34;&#34;
        try:
            dao_obj = EmailDAO(self.db_obj.cursor(dictionary=True))
            dao_obj.bulk_insert_email_snapshot(self.email_obj_list)
            print(&#34;Email snapshot stored\n&#34;)
            self.db_obj.commit()
            return True
        except Exception as ex:
            print(&#34;Exception in store_email_snapshot method %s&#34; % ex)
            raise
        finally:
            self.db_obj.close()

    def retrieve_emails(self, credential_path, service=None):
        &#34;&#34;&#34;
        Brief:
            fetches the email content an stores in the local database

        Pseudo-code:
            retrieves and calls the strategy method for the given service
            calls store data method to store the entity in our DB

        Args:
            credential_path: path of the credential and token file
            service: email service name

        Returns:

        &#34;&#34;&#34;
        try:
            self.retrieve_email_strategy_mapper[service](credential_path)
            self.store_email_snapshots()
            return self.email_obj_list
        except Exception as ex:
            print(&#34;error in processing email %s &#34; % ex)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.email_retriever.EmailRetriever"><code class="flex name class">
<span>class <span class="ident">EmailRetriever</span></span>
</code></dt>
<dd>
<div class="desc"><p>Email Retriever class hosting core methods to retrieve email content
uses the appropriate strategy method
using connector object authenticates and fetches all the emails from server
parses the response message and populates the email entity
stores the email entity in the local database</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmailRetriever:
    &#34;&#34;&#34;
    Email Retriever class hosting core methods to retrieve email content
        uses the appropriate strategy method
        using connector object authenticates and fetches all the emails from server
        parses the response message and populates the email entity
        stores the email entity in the local database
    &#34;&#34;&#34;

    def __init__(self):
        self.email_obj_list = []
        self.db_obj = mysql.connector.connect(
            host=&#34;localhost&#34;,
            user=DB_USERNAME,
            password=DB_PASSWORD,
            database=DATABASE
        )
        self.retrieve_email_strategy_mapper = {
            &#39;google&#39;: self.retrieve_email_google_strategy
        }

    def retrieve_email_google_strategy(self, credentials_path):
        &#34;&#34;&#34;
        Brief:
            Google Email pull strategy method which pulls emails from google servers and populates the local
            email entity

        Pseudo-code:
            calls authentication module first to authenticate and retrieve the OAuth token
            calls batch get email method to retrieve email content from mail server
            calls parse message method to parse and load the email data onto the entity
        Args:
            credentials_path: Path of the credential and token file

        Returns:

        &#34;&#34;&#34;
        try:
            google_services_obj = GoogleConnector(credentials_path=credentials_path)
            print(&#34;Authenticating...&#34;)
            google_services_obj.authenticate()
            print(&#34;Authentication Complete...&#34;)
            google_services_obj.batch_get_emails(parser=self.parse_and_load_messages, criteria=None)
        except Exception as ex:
            print(&#34;exception in connecting to google services and fetching email content :: %s&#34; % ex)
            raise

    def parse_and_load_messages(self, request_id, response, exception):
        &#34;&#34;&#34;
        Brief:
            Method to parse the response and populate the email entity with the appropriate values
        Args:
            request_id: int request id
            response: response object
            exception: HttpError/None
        Returns:
            mail_entity: object
        &#34;&#34;&#34;
        try:
            if exception:
                print(&#34;HTTP error in processing the request&#34;)
                raise
            print(&#34;Parsing message request_id ::&#34; + str(request_id), flush=True)
            email_obj = EmailEntity()
            message_str = base64.urlsafe_b64decode(response[&#39;raw&#39;].encode(&#39;ASCII&#39;))
            email_obj.message_id = response[&#39;id&#39;]
            email_obj.labels = response[&#39;labelIds&#39;]
            mime_message = email.message_from_string(message_str.decode(&#39;ascii&#39;))
            email_obj.from_address = mime_message[&#39;From&#39;]
            email_obj.to_address = mime_message[&#39;To&#39;]
            email_obj.subject = mime_message[&#39;Subject&#39;]
            email_obj.date = parse(mime_message[&#39;Date&#39;], ignoretz=True)
            for parts in mime_message.walk():
                if parts.get_content_type() == &#39;text/plain&#39;:
                    if parts.get(&#39;Content-Transfer-Encoding&#39;):
                        message_content = base64.urlsafe_b64decode(parts.get_payload().encode(&#39;UTF-8&#39;))
                        email_obj.content = message_content.decode(&#39;UTF-8&#39;)
                    else:
                        email_obj.content = parts.get_payload()
            self.email_obj_list.append(email_obj)
        except Exception as ex:
            print(&#34;Exception in parsing email content and populating the entity :: %s&#34; % ex)
            raise

    def store_email_snapshots(self):
        &#34;&#34;&#34;
        Brief:
            Method to store the fetched emails in the database.
        Returns:
            Status: True/False
        &#34;&#34;&#34;
        try:
            dao_obj = EmailDAO(self.db_obj.cursor(dictionary=True))
            dao_obj.bulk_insert_email_snapshot(self.email_obj_list)
            print(&#34;Email snapshot stored\n&#34;)
            self.db_obj.commit()
            return True
        except Exception as ex:
            print(&#34;Exception in store_email_snapshot method %s&#34; % ex)
            raise
        finally:
            self.db_obj.close()

    def retrieve_emails(self, credential_path, service=None):
        &#34;&#34;&#34;
        Brief:
            fetches the email content an stores in the local database

        Pseudo-code:
            retrieves and calls the strategy method for the given service
            calls store data method to store the entity in our DB

        Args:
            credential_path: path of the credential and token file
            service: email service name

        Returns:

        &#34;&#34;&#34;
        try:
            self.retrieve_email_strategy_mapper[service](credential_path)
            self.store_email_snapshots()
            return self.email_obj_list
        except Exception as ex:
            print(&#34;error in processing email %s &#34; % ex)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.email_retriever.EmailRetriever.parse_and_load_messages"><code class="name flex">
<span>def <span class="ident">parse_and_load_messages</span></span>(<span>self, request_id, response, exception)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="brief">Brief</h2>
<p>Method to parse the response and populate the email entity with the appropriate values</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_id</code></strong></dt>
<dd>int request id</dd>
<dt><strong><code>response</code></strong></dt>
<dd>response object</dd>
<dt><strong><code>exception</code></strong></dt>
<dd>HttpError/None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>mail_entity</code></dt>
<dd>object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_and_load_messages(self, request_id, response, exception):
    &#34;&#34;&#34;
    Brief:
        Method to parse the response and populate the email entity with the appropriate values
    Args:
        request_id: int request id
        response: response object
        exception: HttpError/None
    Returns:
        mail_entity: object
    &#34;&#34;&#34;
    try:
        if exception:
            print(&#34;HTTP error in processing the request&#34;)
            raise
        print(&#34;Parsing message request_id ::&#34; + str(request_id), flush=True)
        email_obj = EmailEntity()
        message_str = base64.urlsafe_b64decode(response[&#39;raw&#39;].encode(&#39;ASCII&#39;))
        email_obj.message_id = response[&#39;id&#39;]
        email_obj.labels = response[&#39;labelIds&#39;]
        mime_message = email.message_from_string(message_str.decode(&#39;ascii&#39;))
        email_obj.from_address = mime_message[&#39;From&#39;]
        email_obj.to_address = mime_message[&#39;To&#39;]
        email_obj.subject = mime_message[&#39;Subject&#39;]
        email_obj.date = parse(mime_message[&#39;Date&#39;], ignoretz=True)
        for parts in mime_message.walk():
            if parts.get_content_type() == &#39;text/plain&#39;:
                if parts.get(&#39;Content-Transfer-Encoding&#39;):
                    message_content = base64.urlsafe_b64decode(parts.get_payload().encode(&#39;UTF-8&#39;))
                    email_obj.content = message_content.decode(&#39;UTF-8&#39;)
                else:
                    email_obj.content = parts.get_payload()
        self.email_obj_list.append(email_obj)
    except Exception as ex:
        print(&#34;Exception in parsing email content and populating the entity :: %s&#34; % ex)
        raise</code></pre>
</details>
</dd>
<dt id="src.email_retriever.EmailRetriever.retrieve_email_google_strategy"><code class="name flex">
<span>def <span class="ident">retrieve_email_google_strategy</span></span>(<span>self, credentials_path)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="brief">Brief</h2>
<p>Google Email pull strategy method which pulls emails from google servers and populates the local
email entity</p>
<p>Pseudo-code:
calls authentication module first to authenticate and retrieve the OAuth token
calls batch get email method to retrieve email content from mail server
calls parse message method to parse and load the email data onto the entity</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>credentials_path</code></strong></dt>
<dd>Path of the credential and token file</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_email_google_strategy(self, credentials_path):
    &#34;&#34;&#34;
    Brief:
        Google Email pull strategy method which pulls emails from google servers and populates the local
        email entity

    Pseudo-code:
        calls authentication module first to authenticate and retrieve the OAuth token
        calls batch get email method to retrieve email content from mail server
        calls parse message method to parse and load the email data onto the entity
    Args:
        credentials_path: Path of the credential and token file

    Returns:

    &#34;&#34;&#34;
    try:
        google_services_obj = GoogleConnector(credentials_path=credentials_path)
        print(&#34;Authenticating...&#34;)
        google_services_obj.authenticate()
        print(&#34;Authentication Complete...&#34;)
        google_services_obj.batch_get_emails(parser=self.parse_and_load_messages, criteria=None)
    except Exception as ex:
        print(&#34;exception in connecting to google services and fetching email content :: %s&#34; % ex)
        raise</code></pre>
</details>
</dd>
<dt id="src.email_retriever.EmailRetriever.retrieve_emails"><code class="name flex">
<span>def <span class="ident">retrieve_emails</span></span>(<span>self, credential_path, service=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="brief">Brief</h2>
<p>fetches the email content an stores in the local database</p>
<p>Pseudo-code:
retrieves and calls the strategy method for the given service
calls store data method to store the entity in our DB</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>credential_path</code></strong></dt>
<dd>path of the credential and token file</dd>
<dt><strong><code>service</code></strong></dt>
<dd>email service name</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_emails(self, credential_path, service=None):
    &#34;&#34;&#34;
    Brief:
        fetches the email content an stores in the local database

    Pseudo-code:
        retrieves and calls the strategy method for the given service
        calls store data method to store the entity in our DB

    Args:
        credential_path: path of the credential and token file
        service: email service name

    Returns:

    &#34;&#34;&#34;
    try:
        self.retrieve_email_strategy_mapper[service](credential_path)
        self.store_email_snapshots()
        return self.email_obj_list
    except Exception as ex:
        print(&#34;error in processing email %s &#34; % ex)</code></pre>
</details>
</dd>
<dt id="src.email_retriever.EmailRetriever.store_email_snapshots"><code class="name flex">
<span>def <span class="ident">store_email_snapshots</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="brief">Brief</h2>
<p>Method to store the fetched emails in the database.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Status</code></dt>
<dd>True/False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_email_snapshots(self):
    &#34;&#34;&#34;
    Brief:
        Method to store the fetched emails in the database.
    Returns:
        Status: True/False
    &#34;&#34;&#34;
    try:
        dao_obj = EmailDAO(self.db_obj.cursor(dictionary=True))
        dao_obj.bulk_insert_email_snapshot(self.email_obj_list)
        print(&#34;Email snapshot stored\n&#34;)
        self.db_obj.commit()
        return True
    except Exception as ex:
        print(&#34;Exception in store_email_snapshot method %s&#34; % ex)
        raise
    finally:
        self.db_obj.close()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.email_retriever.EmailRetriever" href="#src.email_retriever.EmailRetriever">EmailRetriever</a></code></h4>
<ul class="">
<li><code><a title="src.email_retriever.EmailRetriever.parse_and_load_messages" href="#src.email_retriever.EmailRetriever.parse_and_load_messages">parse_and_load_messages</a></code></li>
<li><code><a title="src.email_retriever.EmailRetriever.retrieve_email_google_strategy" href="#src.email_retriever.EmailRetriever.retrieve_email_google_strategy">retrieve_email_google_strategy</a></code></li>
<li><code><a title="src.email_retriever.EmailRetriever.retrieve_emails" href="#src.email_retriever.EmailRetriever.retrieve_emails">retrieve_emails</a></code></li>
<li><code><a title="src.email_retriever.EmailRetriever.store_email_snapshots" href="#src.email_retriever.EmailRetriever.store_email_snapshots">store_email_snapshots</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>